<!-- File: templates/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dynamic Sensor Data Dashboard</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
  <!-- Navigation Links -->
  <a href="/tabular" class="btn btn-secondary">Go to Tabular View</a>
  <style>
    /* Basic styles */
    body {
      margin: 0;
      font-family: 'Roboto', sans-serif;
      background-color: #1e1e2f;
      color: #ffffff;
    }
    header {
      background-color: #29293d;
      padding: 20px;
      text-align: center;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    header h1 {
      margin: 0;
      font-size: 26px;
      font-weight: bold;
      letter-spacing: 1px;
      color: #ffffff;
    }
    .container {
      display: flex;
      flex-wrap: wrap;
      padding: 20px;
      gap: 20px;
    }
    .sidebar {
      flex: 1 1 300px;
      max-width: 300px;
      background-color: #29293d;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    .sidebar label {
      display: block;
      margin-bottom: 10px;
      font-weight: bold;
      color: #a1a1a1;
    }
    .sidebar select {
      width: 100%;
      padding: 10px;
      margin-bottom: 20px;
      border: none;
      border-radius: 4px;
      background-color: #3e3e5e;
      color: #ffffff;
      font-size: 14px;
    }
    .content {
      flex: 3 1 700px;
      background-color: #29293d;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    /* Increased height for bigger graph */
 .chart-container {
  height: 600px; /* Reduced height */
  width: 100%;
  position: relative;
  margin-bottom: 40px; /* Add space for x-axis labels */
}

/* Add to existing style */
.plot-container .xaxislayer-above {
  transform: translateY(30px); /* Push x-axis labels down */
}
    .hidden {
      display: none !important;
    }
    .fan-card-container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      justify-content: space-around;
    }
    .fan-card {
      background-color: #3e3e5e;
      color: #ffffff;
      width: 200px;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .fan-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }
    .fan-card h3 {
      margin: 0;
      font-size: 20px;
    }
    .fan-status, .rotor-status, .pipe-status {
      margin-top: 15px;
      font-size: 18px;
      font-weight: bold;
      padding: 5px;
      border-radius: 5px;
      text-align: center;
    }
    .status-on {
      color: white;
      background-color: #2e6a2f;
      padding: 5px;
      border-radius: 5px;
    }
    .status-off {
      color: white;
      background-color: #6a2e2f;
      padding: 5px;
      border-radius: 5px;
    }
    footer {
      text-align: center;
      margin-top: 20px;
      padding: 10px;
      background-color: #29293d;
      border-top: 2px solid #444;
      color: #aaa;
    }
    footer a {
      color: #4caf50;
      text-decoration: none;
    }
    footer a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <header>
    <h1>Dynamic Sensor Data Dashboard</h1>
  </header>
  <div class="container">
    <!-- Sidebar for Filters -->
    <div class="sidebar">
      <label for="building-id">Select Building:</label>
      <select id="building-id" onchange="updateFloorsAndData()">
        <option value="all">All Buildings (Average)</option>
      </select>

      <label for="floor-id">Select Floor:</label>
      <select id="floor-id" onchange="updateData()">
        <option value="all">All Floors (Average)</option>
      </select>

      <label for="sensor-type">Select Sensor Type:</label>
      <select id="sensor-type" onchange="updateData()">
        <!-- Sensor types will be populated dynamically -->
      </select>

      <label for="timeline">Select Timeline:</label>
      <select id="timeline" onchange="updateData()">
          <option value="live">Live</option>
          <option value="5min">5 minutes</option>
          <option value="10min">10 minutes</option>
          <option value="15min">15 minutes</option>
          <option value="30min">30 minutes</option>
          <option value="hourly">Hourly</option>
          <option value="daily">Daily</option>
          <option value="weekly">Weekly</option>
          <option value="monthly">Monthly</option>
          <option value="yearly">Yearly</option>
      </select>
      
      <label for="aggregation">Select Aggregation:</label>
      <select id="aggregation" onchange="updateData()">
        <option value="raw">Live</option>
        <option value="min">Min</option>
        <option value="max">Max</option>
        <option value="avg">Average</option>
      </select>

      <label for="chart-type">Select Chart Type:</label>
      <select id="chart-type" onchange="updateData()">
        <option value="line">Line Chart</option>
        <option value="bar">Bar Chart</option>
        <option value="pie">Pie Chart</option>
        <option value="scatter">Scatter Plot</option>
        <option value="box">Box Plot</option>
      </select>
    </div>
    <div>
        <a href="/export">
            <button style="background-color: #28a745;">Go to Export Page</button>
       </a>
    </div>
    <!-- Main Content -->
    <div class="content">
      <!-- Chart or Fan Cards -->
      <div id="chart" class="chart-container hidden"></div>
      <div id="fan-cards" class="fan-card-container hidden"></div>
    </div>
  </div>
  <footer>
    <p>&copy; 2025 <a href="#">ASHIDA Solutions</a></p>
  </footer>

  <script>
    // Helper function to calculate the week of the year
    function getWeekOfYear(date) {
      const startOfYear = new Date(date.getFullYear(), 0, 1);
      const pastDaysOfYear = (date - startOfYear) / 86400000;
      return Math.ceil((pastDaysOfYear + startOfYear.getDay() + 1) / 7);
    }

    // Fetch available buildings
    fetch('/buildings')
      .then(response => response.json())
      .then(buildings => {
        const buildingSelect = document.getElementById('building-id');
        buildings.forEach(building => {
          const option = document.createElement('option');
          option.value = building;
          option.textContent = building;
          buildingSelect.appendChild(option);
        });
        updateFloorsAndData(); // Initial data fetch
      });

    // Fetch available sensor types
    fetch('/sensor-types')
      .then(response => response.json())
      .then(sensorTypes => {
        const sensorTypeSelect = document.getElementById('sensor-type');
        sensorTypes.forEach(sensorType => {
          const option = document.createElement('option');
          option.value = sensorType;
          option.textContent = sensorType;
          sensorTypeSelect.appendChild(option);
        });
        updateData(); // Optionally, trigger an initial data update
      });

    // Fetch floors for selected building
    function updateFloorsAndData() {
      const buildingId = document.getElementById('building-id').value;
      fetch(`/floors/${buildingId}`)
        .then(response => response.json())
        .then(floors => {
          const floorSelect = document.getElementById('floor-id');
          floorSelect.innerHTML = '<option value="all">All Floors (Average)</option>';
          floors.forEach(floor => {
            const option = document.createElement('option');
            option.value = floor;
            option.textContent = `Floor ${floor}`;
            floorSelect.appendChild(option);
          });
          updateData(); // Fetch data for selected building and floor
        });
    }

    // Fetch and display sensor data based on selected filters
    function updateData() {
      const buildingId = document.getElementById('building-id').value;
      const floorId = document.getElementById('floor-id').value;
      const sensorType = document.getElementById('sensor-type').value;
      const timeline = document.getElementById('timeline').value;
      const aggregation = document.getElementById('aggregation').value;
      const chartType = document.getElementById('chart-type').value;

      fetch(`/data/${buildingId}/${floorId}/${sensorType}/${timeline}/${aggregation}`)
        .then(response => response.json())
        .then(data => {
          if (sensorType === 'digital') {
            generateFanCards(data);
          } else {
            generateChart(data, sensorType, chartType, timeline);
          }
        });
    }

    // Generate chart for non-digital sensors
    function generateChart(data, sensorType, chartType, timeline) {
      const chartContainer = document.getElementById('chart');
      chartContainer.innerHTML = '';  // Clear existing chart

      // Sort and group data by timeline
      data.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
      const groupedData = groupDataByTimeline(data, timeline);
      console.log('Grouped Data:', groupedData); // Debug log

      const timestamps = groupedData.timestamps;
      const values = groupedData.values;
      const unit = data.length ? data[0].unit : '';

      let trace = {};
      switch (chartType) {
        case 'line':
          trace = {
            x: timestamps,
            y: values,
            type: 'scatter',
            mode: 'lines+markers',
            name: sensorType,
          };
          break;
        case 'bar':
          trace = {
            x: timestamps,
            y: values,
            type: 'bar',
            name: sensorType,
          };
          break;
        case 'pie':
          trace = {
            labels: timestamps,
            values: values,
            type: 'pie',
            name: sensorType,
          };
          break;
        case 'scatter':
          trace = {
            x: timestamps,
            y: values,
            type: 'scatter',
            mode: 'markers',
            name: sensorType,
            marker: {
              size: 10,
              color: '#4CAF50',
            },
          };
          break;
        case 'box':
          trace = {
            y: values,
            type: 'box',
            name: sensorType,
          };
          break;
      }

      const layout = {
        title: `${sensorType.charAt(0).toUpperCase() + sensorType.slice(1)} over Time`,
        xaxis: {
          title: 'Time',
          type: 'category',
        },
        yaxis: {
          title: `${sensorType.charAt(0).toUpperCase() + sensorType.slice(1)} (${unit})`,
        },
      };

      Plotly.newPlot(chartContainer, [trace], layout);
      chartContainer.classList.remove('hidden');
      document.getElementById('fan-cards').classList.add('hidden');
    }

    // Group data based on the selected timeline
    function groupDataByTimeline(data, timeline) {
      const grouped = {
        timestamps: [],
        values: [],
      };

      let currentPeriod = null;
      let tempValues = [];

      data.forEach(item => {
        const timestamp = new Date(item.timestamp);
        let periodKey = '';

        switch (timeline) {
          case 'live':
            // Use the raw timestamp as-is (no grouping)
            periodKey = timestamp.toISOString();
            break;
          case '5min':
            periodKey = roundToNearestMinutes(timestamp, 5);
            break;
          case '10min':
            periodKey = roundToNearestMinutes(timestamp, 10);
            break;
          case '15min':
            periodKey = roundToNearestMinutes(timestamp, 15);
            break;
          case '30min':
            periodKey = roundToNearestMinutes(timestamp, 30);
            break;
          case 'hourly':
            periodKey = `${timestamp.getFullYear()}-${timestamp.getMonth() + 1}-${timestamp.getDate()} ${timestamp.getHours()}:00`;
            break;
          case 'daily':
            periodKey = `${timestamp.getFullYear()}-${timestamp.getMonth() + 1}-${timestamp.getDate()}`;
            break;
          case 'weekly':
            periodKey = `${timestamp.getFullYear()}-W${getWeekOfYear(timestamp)}`;
            break;
          case 'monthly':
            periodKey = `${timestamp.getFullYear()}-${timestamp.getMonth() + 1}`;
            break;
          case 'yearly':
            periodKey = `${timestamp.getFullYear()}`;
            break;
          default:
            periodKey = timestamp.toISOString();
            break;
        }

        // If the periodKey changes, store the aggregated value for the previous group.
        if (periodKey !== currentPeriod) {
          if (tempValues.length > 0 && currentPeriod !== null) {
            grouped.timestamps.push(currentPeriod);
            const avg = tempValues.reduce((sum, v) => sum + v, 0) / tempValues.length;
            grouped.values.push(avg);
          }
          currentPeriod = periodKey;
          tempValues = [];
        }
        tempValues.push(item.value);
      });

      // Push the last group if available
      if (tempValues.length > 0) {
        grouped.timestamps.push(currentPeriod);
        const avg = tempValues.reduce((sum, v) => sum + v, 0) / tempValues.length;
        grouped.values.push(avg);   
      }

      return grouped;
    }

    // Rounds the date to the nearest specified minutes and returns a simple HH:MM format
    function roundToNearestMinutes(date, minutes) {
      const ms = 1000 * 60 * minutes;
      const roundedDate = new Date(Math.floor(date.getTime() / ms) * ms);
      return roundedDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    // Generate fan cards for digital sensors
    function generateFanCards(data) {
      const fanCardsContainer = document.getElementById('fan-cards');
      fanCardsContainer.innerHTML = ''; // Clear existing fan cards

      data.forEach(item => {
        const fanCard = document.createElement('div');
        fanCard.classList.add('fan-card');

        // Convert database values (0/1) to "ON"/"OFF"
        const fanStatus = item.fan_status === 1 ? 'ON' : 'OFF';
        const rotorStatus = item.rotor_status === 1 ? 'ON' : 'OFF';
        const pipeStatus = item.pipe_status === 1 ? 'ON' : 'OFF';

        // Assign status classes dynamically
        const fanStatusClass = fanStatus === 'ON' ? 'status-on' : 'status-off';
        const rotorStatusClass = rotorStatus === 'ON' ? 'status-on' : 'status-off';
        const pipeStatusClass = pipeStatus === 'ON' ? 'status-on' : 'status-off';

        fanCard.innerHTML = `
          <h3>Fan ID: ${item.fan_id} <br> Building: ${item.building_id} | Floor: ${item.floor_number}</h3>
          <div class="fan-status ${fanStatusClass}">
            Fan: ${fanStatus}
          </div>
          <div class="rotor-status ${rotorStatusClass}">
            Rotor: ${rotorStatus}
          </div>
          <div class="pipe-status ${pipeStatusClass}">
            Pipe: ${pipeStatus}
          </div>
        `;
        fanCardsContainer.appendChild(fanCard);
      });

      fanCardsContainer.classList.remove('hidden');
      document.getElementById('chart').classList.add('hidden');
    }
    setInterval(updateData, 10000);
  </script>
</body>
</html>
